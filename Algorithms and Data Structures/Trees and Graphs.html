<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/style.css" type="text/css">
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#type-of-trees">Type of Trees</a></li>
<li><a href="#trees-vs-binary-trees">Trees vs Binary Trees</a></li>
<li><a href="#binary-trees-vs-binary-search-trees">Binary Trees vs Binary Search Trees</a></li>
<li><a href="#balanced-vs-unbalanced">Balanced vs Unbalanced</a></li>
<li><a href="#complete-binary-tree">Complete Binary Tree:</a></li>
<li><a href="#full-binary-tree">Full Binary Tree:</a></li>
<li><a href="#perfect-binary-tree">Perfect Binary Tree:</a></li>
<li>
<a href="#binary-tree-traversal">Binary Tree Traversal</a><ul>
<li><a href="#in-order-traversal">In-Order Traversal</a></li>
<li><a href="#pre-order-traversal">Pre-Order Traversal</a></li>
<li><a href="#post-order-traversal">Post-Order Traversal</a></li>
</ul>
</li>
<li><a href="#binary-heaps-min-heaps-and-max-heaps">Binary Heaps (Min-Heaps and Max-Heaps)</a></li>
<li>
<a href="#tries-prefix-trees">Tries (Prefix Trees)</a><ul>
<li><a href="#tries-with-array">Tries with Array:</a></li>
<li><a href="#tries-with-map">Tries with Map</a></li>
</ul>
</li>
</ul>
</div>
<p>Trees and Graphs</p>
<h2 id="type-of-trees">Type of Trees</h2>
<p>A nice way to understand a tree is with a recursive explanation. A tree is a data structure composed of nodes.<br>
Each tree has a root node.<br>
The root node has zero or more child nodes<br>
Each child node has zero or more child nodes and so on</p>
<p>The tree cannot contain cycles. The nodes may or may not be in a particular order, they could have any data types as values, and they may or may not have links back to their parent nodes,</p>
<h2 id="trees-vs-binary-trees">Trees vs Binary Trees</h2>
<p>A binary tree is a tree in which each node has up to two children. A node is called a "leaf" node if it has no children</p>
<h2 id="binary-trees-vs-binary-search-trees">Binary Trees vs Binary Search Trees</h2>
<p>A binary search tree is a binary tree in which every node fits a specific ordering property:</p>
<p><code>all left descendents &lt;= n &lt; all right descendents</code>.</p>
<p>Note that this inequality must be true for all node's descendents, not just its immediate children.</p>
<h2 id="balanced-vs-unbalanced">Balanced vs Unbalanced</h2>
<p>Note that balancing a tree does not mean the left and right subtrees are exactly the same size</p>
<p>It is balanced enough to ensure <code>O(log n)</code> times for insert and find.</p>
<h2 id="complete-binary-tree">Complete Binary Tree:</h2>
<p>A binary tree in which every level of the tree is fully filled with the exception for the last level which is still filled from left to right</p>
<h2 id="full-binary-tree">Full Binary Tree:</h2>
<p>Every node has either two or zero children</p>
<h2 id="perfect-binary-tree">Perfect Binary Tree:</h2>
<p>Both full and complete, maximum number of nodes for given level</p>
<h2 id="binary-tree-traversal">Binary Tree Traversal</h2>
<h3 id="in-order-traversal">In-Order Traversal</h3>
<p>In-order traversal means to "visit" (often, print) the left branch, the the current node, and finally the right branch. When performed on a binary search tree, it visits the nodes in ascending order</p>
<p><code>travel(node.left);</code><br>
<code>visit(node);</code><br>
<code>travel(node.right);</code></p>
<h3 id="pre-order-traversal">Pre-Order Traversal</h3>
<p>Pre order traversal visits the current node before its child nodes. The root is always the first node to visit</p>
<p><code>visit(node);</code><br>
<code>travel(node.left);</code><br>
<code>travel(node.right);</code></p>
<h3 id="post-order-traversal">Post-Order Traversal</h3>
<p>Post-order traversal visits the current node after its child nodes. The root is always the last node to visit</p>
<p><code>travel(node.left);</code><br>
<code>travel(node.right);</code><br>
<code>visit(node);</code></p>
<h2 id="binary-heaps-min-heaps-and-max-heaps">Binary Heaps (Min-Heaps and Max-Heaps)</h2>
<p>A min heap is a complete binary tree (totally filled every level except for last level which is filled from left to right). Where each node is smaller than its children. The root is the minimum element of the tree</p>
<p><code>insert():</code><br>
When we insert into a min-heap we always start by inserting the element at the bottom, we insert at the rightmost sport as to maintain the complete tree property<br>
The we fix the tree by swapping, the new element with its parent, until we find an appropriate spot, essentially bubble up the minimum element<br>
Takes O(logn) time where n is the number of nodes in the heap</p>
<p><code>extract_min():</code><br>
Extracting minimum element<br>
Always at the top, trickier part is how to remove<br>
First we remove the element and swap it with the last element in the heap (bottom right most) The we bubble down this element, swapping it with its smallest children until the min heap property is restored.</p>
<p>Swapping with smallest children guarantees that root is still smallest, since we know that none of grandchildren can be smaller the child, no can any of the other node's children can be smaller (since it was a valid min heap before).<br>
This algorithm takes O(logn) time</p>
<h2 id="tries-prefix-trees">Tries (Prefix Trees)</h2>
<p>A trie (prefix) is a variant of an n-ary tree in which characters are stored at each node, Each path down the tree may represent a word<br>
The <code>*</code> Node (sometimes called "null node") are often used to indicate complete words. The actual implementation of these * nodes might be a special type of child or a boolean flag that terminates<br>
A node in a trie could have anywhere from 1 through ALPHABET_SIZE + 1 children</p>
<p>Very commonly, a true is used to sore the entire (English) language for quick prefix lookup. Which a hash table can quickly look up whether a string is a valid word, it cannot tell us if a string is a prefix of any valid words. A trie can do this very quickly</p>
<p>Many problems involving lists of valid words leverage a tries as an optimization. In situations when we search through a tree on related prefixes repeatedly (e.g lookup M then MA then MAN then MANY) we might pass around a reference to the current node in the tree. This will allow us to just check if Y is a child of MAN rather than starting from the root each time</p>
<h3 id="tries-with-array">Tries with Array:</h3>
<p>use an array to store children nodes<br>
For instance, if store strings which only contains letter a to z we can declare an array whose size is 26 in each node to store its children nodes, And for a specific character c, we can use c to store 'a' as the index to find the corresponding child node in the array<br>
It is really fast to visit a child node. It is comparatively easy to visit a specific child since we can easily transfer a character to an index in most cases. But not all children nodes are needed. So there might be some waste of space</p>
<pre><code>class TrieNode {
    // change this value to adapt to different cases
    public static final N = 26;
    public TrieNode[] children = new TrieNode[N];
    
    // you might need some extra values according to different cases
};</code></pre>
<pre><code>/** Usage:
 *  Initialization: TrieNode root = new TrieNode();
 *  Return a specific child node with char c: root.children[c - 'a']
 */</code></pre>
<h3 id="tries-with-map">Tries with Map</h3>
<p>Use a hashmap to store children nodes<br>
We can declare a hashmap in each node. The key of the hashmap are characters and they value is the corresponding child node</p>
<p>Graphs:<br>
A tree is actually a type of graph, but not all graphs are trees. Simply put, a tree is a connected graph without cycles</p>
<p>A graph is simply a collection of nodes with edges between some of them<br>
Graphs can either be directed or undirected<br>
Directed Edges are like one way streets<br>
Undirected Edges are like a two way street<br>
The graph might consists of multiple isolated subgraphs. If there is a path between every pair of vertices (nodes) it is called a connected graph<br>
Graphs can contain cycles, graph without cycles is called Acyclic graph</p>
<p>Adjacency List:<br>
This is the most common way to represent a graph, Every vertex (or node) stores a list of adjacent vertices. In an undirected graph, an edge like (a,b) would be stored twice: once in a adjacent vertices and once in b's adjacent vertices</p>
<p>We also need to use a graph class because unlike trees, you can't necessarily reach all the nodes from a single node.</p>
<p>We don't need any additional classes to represent a graph. An array (or a hashtable) of lists (arrays, arraylist,linkedlist etc) can store the adjacency list.</p>
<p>Adjacency Matrix<br>
An adjacency matrix is a nxn boolean matrix where n is the number of nodes and where true value at matrix[i][j] indicates an edge from i to j.</p>
<p>In an undirected graph, an adjacency matrix will be symmetrics. In a directed graph, it will not (necessarily) be.</p>
<p>The same graph algorithms that are used on adjacency list (bfs, etc) can be performed on adjacency matrix. but they are less efficient.<br>
In the adjacency list representation you can easily iterate through the neighbours of a node<br>
In the adjacency matrix representation you will need to iterate through all the nodes to identify a node's neighbours.</p>
<p>Graph Search</p>
<p>Depth First Search:<br>
We start at the root (or another arbitrarily selected node) and explore each branch completely before moving to the next branch that is we go deep first before we go wide</p>
<p>Breadth First Search:<br>
We start at the root (or another arbitrarily selected node) and explore each neighbour before going to any of its children. That is go wide before we go deep.</p>
<p>TODO the cute graph</p>
<p>Scenarios:<br>
DFS is prefered if we want to visit every node in the graph. (both work)<br>
BFS is prefered (better) for shortest path (or any path) between two nodes (path of friendship)</p>
<p>Depth First Search:<br>
In DFS, we visit a node a and the iterate through each of a's neighbors,<br>
When visiting a node b that neighbor of a,<br>
we visit all of b's neighbours<br>
before going on to a's other neighbors<br>
We exhaustively search b's branch before any of its others neighbours</p>
<p>Note: that pre-order and other forms forms of tree traversal are a form of DFS</p>
<p>The key difference is that when implementing this algorithm for a graph, we must check if the node has been visited. If we don't, we risk getting caught in an infinite loop . (if n.visited == false)</p>
<p>Breadth First Search<br>
Protip: use a queue</p>
<p>BFS is a bit less intuitive. The main tripping point is the that BFS is NOT RECURSIVE, it must use a queue.</p>
<p>In BFS node a visits each of a's neighbors before visiting any of their neighbors. You can think of this as searching level by level out from a. an Iterative solution works best</p>
<p>If you are asked to implement BFS, the key thing to remember is to use the queue. The rest of the algo flows from this fact.</p>
      <div id="footer">
        Notes by <a href="https://github.com/yfjd01.github.io">Yifan Dai</a>, 
        Connect with me on <a href="https://www.linkedin.com/in/yfjd01/">LinkedIn</a>.
      </div>
</body>
</html>
