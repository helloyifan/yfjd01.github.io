<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <meta name="generator" content="pandoc">
  
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/style.css" type="text/css">
</head>
<body>
<p>Recursion and Dynamic Programming</p>
<p>While there are a large number of recursive problems, many follow similar patterns. A good hint is that a problem is recursive is that it can be built off of subproblems.</p>
<p>When you hear a problem beginning with the following statements, it's often (though not always) a good candidate for recursion.<br>
Design an algorithm to compute the nth...<br>
Write code to list the first n ...<br>
Implement a method to compute all..</p>
<p>How to Approach<br>
Recursive solutions, by definitions are built off of solutions to subproblems. Many times, this will mean simply to compute f(n) by adding something, removing something, or otherwise changing the solution for f(n-1).<br>
In other cases you might solve the problem for the first half of the data set, the the second halfm and the merge those results</p>
<p>There are many ways you might divide a problem into subproblems. Three of the most common approaches to develop an algorithm are bottom-up, top-down, and half and half</p>
<p>Bottom-Up<br>
Top-Down<br>
Half and Half</p>
<p>Your DP Glossary</p>
<p>Memoization:<br>
Most important term, often conflated with dynamic programming<br>
Technique for storing computed value<br>
Use this to store the results of repeated computations<br>
sounds like "memorization"</p>
<p>Two characteristics of DP problems (formal definition)<br>
To be effectively optimized using DP a problem must have<br>
Optimal Substructure<br>
Overlapping Subproblems</p>
<p>Optimal Substructure<br>
We can find the optimal solution to the problem by knowing the optimal solution to the subproblems<br>
Basically recursion</p>
<p>Overlapping Subproblems<br>
Recursive functions break problems into subproblems<br>
We sometimes compute the same subproblem more than once<br>
This is unnecessary work that can be optimized</p>
<p>Two types of DP solutions<br>
We can use dynamic programming in 2 different ways<br>
Top-down<br>
Bottom-up</p>
<p>Top-down<br>
A recursive solution<br>
Start at the "top" and break down the problem into subproblems<br>
Often easier to understand the logic of the problem</p>
<p>Bottom UP<br>
Opposite of top down<br>
Build up solutions iteratively<br>
Start with the base case and progressively solve large subproblems<br>
Often faster due to the slowness of recursion call</p>
<p>Top-down versus bottom-up<br>
Both are equally valid</p>
<p>Can I solve this problem using DP<br>
Check if the problem can be solved with optimal substructure and it has overlapping subproblems<br>
Thus find a brute force solution first<br>
Draw a diagram of the solution</p>
<p>Quick Problem Identification<br>
Common patterns so you can quickly identify potential DP problems<br>
Maximization<br>
Minimization<br>
Optimization<br>
Counting<br>
Ask yourself if you can solve this problem by enumerating all the possibility.</p>
<p>DP versus Greedy Algorithm<br>
Greedy algorithms consider only local optimization<br>
Dynamic programming problem consider every option (look at every path and see what is the shortest)<br>
Can we make 100% accurate decisions using only historical data?<br>
(the we can use greedly, otherwise we have to use DP)<br>
Try to identify counterexample to disprove you can use a greedy algorithm</p>
<p>The FAST method<br>
A generalized approach to solving any dynamic programming problem<br>
Takes the brute force solution and optimizes it<br>
Walks through both top down and bottom up solutions<br>
Uses top down to find bottom up</p>
<p>FAST<br>
Finding the First solution<br>
Analyze the first solution<br>
Identify the Subproblems<br>
Turn around the solution</p>
<p>Framework for solving dynamic programming problems (like a recipe)<br>
As you get more comfortable, you can deviate as necessary<br>
Framework centers you when you get stuck</p>
<p>Demo Problems<br>
Fibonacci numbers<br>
Given an integer n, write a function to return the nth fibonacci number<br>
Number of Combinations<br>
Given an array of integers write a function to compute the total number of combinations of integers</p>
<ol><li>Find the first solution<br>
Let's find a recursive brute force solution</li></ol>
<p>Notes on recursion<br>
We need to compute each subproblem separately and combine them<br>
Without input from outside (for example global variables)<br>
No passing through a result array<br>
Cant pass by reference<br>
Avoid global variables and all unnecessary variables</p>
<ol><li>Analyze the brute force solution<br>
Figure out can we use Dynamic programming?<br>
Our two criteria<br>
So does it have optimal substructure<br>
does it have overlapping subproblems?<br>
Is our current solution inefficient</li></ol>
<p>Fibonacci Numbers Brute force Analysis<br>
Has optimize substructures<br>
Yes it does, because we are solving it recursively with discrete subproblems<br>
Do we have overlapping subproblems?<br>
Draw a diagram (execution tree) to see if there are overlapping subproblems<br>
Tip: ignore base cases<br>
Yes it does, we can reuse the solutions we computed</p>
<p>Time complexity for recursive function<br>
Generally can be computed from branching factor and maximum tree height<br>
At each level of the tree we increase the number of subproblems by a branching factor. Therefore we get BF * BF * BF * â€¦ or branching factor ^maximum height<br>
O(branching factor^maximum height)</p>
<p>Array Combinations Brute force Analysis<br>
Has optimal substructure<br>
Yes it does, because recursion<br>
Do we have overlapping subproblems?<br>
Draw a diagram<br>
Yes each "level" is the same subproblem<br>
Branching factor is 2 and height of tree is arr.length (call that n)<br>
Time complexity is O(2^n)<br>
Same complexity is O(n) (we are at going N deep)</p>
<p>Key Takeaways of 2.<br>
Drawing a diagram is the best way to understand recursive functions<br>
Diagrams help us see the subproblems and verify that we do have optimal substructures<br>
O(branching factors ^maximum height)<br>
Both of our problems can be optimized using DP, so we can move on to the next step.</p>
<ol><li>Identifying the Subproblems<br>
We will be memoizing subproblems results to avoid recomputing<br>
Need to know exactly what the subproblems are<br>
We can approximately identify the subproblems by finding the recursive calls in our code<br>
However, the key is to define them in plain English</li></ol>
<p>Fibonacci Numbers<br>
Add to dp array whenever we compute anything<br>
Do look up first only compute if we don't have it in do<br>
No need to put base case in dp array<br>
Much more efficient code<br>
Only compute each subproblem once<br>
Time complexity of O(n)<br>
Space Complexity of O(n): depth of recursion O(n) + space used by array O(n)</p>
<p>Array combinations<br>
More difficult to nail down the subproblems<br>
Subproblems we call are combinations(arr,i+1)<br>
In plain English, combination (arr, i ) is the number of combinations of elements i through n<br>
Pay attention to which variables change from call to call, those variables will be a candidate for i in dp[i] or which variables does the result of the variables depend on</p>
<p>We are only computing each subproblem once, thus the runtime is the number of subproblems we have ie the number of keys we have in our dp which is often O(n).</p>
<p>Key Takeaways<br>
We can identify subproblems by looking at recursive calls<br>
key key, Describe the subproblems in plain english<br>
It is easy to add a cache and get a dynamic solution.</p>
<ol><li>Turn Around the solution</li></ol>
<p>Why bother?<br>
Recursive solutions are often slower<br>
Shorter, more straightforward code<br>
Easier to reason about complexity of iterative code</p>
<p>Turn around the solution<br>
use the subproblems we identified easier<br>
Start with the bases cases (s) and iteratively solve larger subproblems</p>
<p>Fibonacci Number Example<br>
Start with the base cases (fib(0) and fib(1))<br>
Iteratively fill in the remainder of the cache<br>
Return dp[n]<br>
Code is much more straightforward<br>
Was to see O(n) time complexity and space because of for loop</p>
<p>Key Takeaways<br>
Focus on the subproblems that we previously identified<br>
If you're iterating over an array, it is helpful to flip the subproblem definition, so that we can build up from 0 to n instead of n to 0<br>
This is simple at a high level but can quickly gain complexity</p>
<p>Sorting and Searching<br>
Understanding the common sorting and searching algorithms is incredibly valuable, as many sory and searching problems are tweaks of well known approach.</p>
<p>Learning the common sorting algorithms is a great way to boost your performance. Of the five algorithms explained below, Merge sort, Quick Sort and Bucket sort are the most commonly used in interviews.</p>
<p>Bubble Sort: O(n^2) average and worst case. Memory O(1)</p>
<p>In bubble sort, we start at the beginning of the array and swap the first two elements, if the first is greater than the second.<br>
The we go to the next pair and so on, continuously making sweeps of the array until it is sorted.<br>
In doing so, the smaller item slowly "bubbles" up to the beginning of the list</p>
<p>Merge Sort O(nlogn) average and worst case</p>
<p>Merge sort divides the array in half, sorts each of those halves and the merges them back together.<br>
Each of those halves has the same sorting algorithm applied to it<br>
Eventually you are merging just two single element arrays .</p>
<p>The merge method operates by copying all the elements from the target array segment into a helper array,<br>
Keeping track of where the start of the left and right halves should be.<br>
We the iterate through helper, copying the smaller element from each half into the array. At the end we copy any remaining elements into the target array</p>
      <div id="footer">
        Notes by <a href="https://github.com/yfjd01.github.io">Yifan Dai</a>, 
        Connect with me on <a href="https://www.linkedin.com/in/yfjd01/">LinkedIn</a>.
      </div>
</body>
</html>
